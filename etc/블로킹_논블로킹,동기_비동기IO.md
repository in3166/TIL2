# 블로킹(Blocking)과 논블로킹(Non-Blocking)
- **프로세스의 유휴 상태에 대한 개념**
- 멀티 스레딩, [I/O](https://blackinkgj.github.io/IO/) 등에서 사용되는 개념이며, 함수의 리턴 시점과 제어권에 따라 차이

## Blocking I/O
- CPU의 기본적인 I/O 모델
- 리눅스에서 모든 소켓 통신의 기본 동작 방식
- I/O 작업이 진행되는 동안 유저 프로세스는 자신의 작업을 중단한 채 대기하는 방식
- 애플리케이션 실행 시 운영체제 대기 큐에 들어가면서 요청에 대한 system call이 완료된 후에 응답을 보낸다.
```
응답: 네트워크 모델에선 서버의 응답, I/O 모델에서는 프로세스 제어권의 반납
```

- 제어권이 호출된 함수에게 넘어가서 호출된 함수 내에서 작업이 모두 끝난 후 값이 리턴되고, 이와 동시에 호출한 함수에게 다시 제어권이 넘어온다.

<img src="https://github.com/in3166/TIL/blob/main/etc/img/block1.png" width="60%" />

```
1. User가 커널에 Read 작업 요청
2. 데이터 입력까지 대기
3. 데이터가 입력되면 User에게 커널이 결과 전달
```
<br>

## Non-Blocking I/O
- I/O 작업이 진행되는 동안 유저 프로세스는 자신의 작업을 중단시키지 않는 방식
  - 애플리케이션 실행 시 운영체제 대기 큐에 들어가지 않고, 실행 여부와 관계없이 바로 응답을 보낸다. 
  - 바로 응답하기 힘든 경우, 에러를 반환하는데 정상데이터를 받을 때까지 계속해서 요청을 다시 보낸다.
  
- 호출 직후 프로그램으로부터 제어가 돌아옴으로서 시스템 호출 종료를 기다리지 않고 다음 처리로 넘어간다.
- 제어권은 계속 호출한 함수에 있고, 값의 리턴이 함수의 실행과 동시에 이루어진다.

<img src="https://github.com/in3166/TIL/blob/main/etc/img/nonblock1.png" width="60%" />

```
1. User가 커널에 Read 작업 요청
2. 데이터 입력 유무에 상관없이 바로 결과 반환 (데이터 없으면 없다는 결과 메시지 EWOULDBLOCK)
3. 데이터가 입력되면 1-2 반복 (2번에서 결과 메시지를 받은 유저는 다른 작업 진행)
4. 입력 데이터가 있다면 커널이 유저에게 결과 전달
```

<br><br>

# I/O 이벤트 통지 모델
- `Non-Blocking I/O`는 반복적으로 시스템 호출이 발생해 자원 낭비 발생
- 이벤트: `수신 버퍼`나 `출력 버퍼`에서 데이터를 처리하는 동작

```
수신 버퍼의 이벤트 -> 입력 버퍼에 데이터가 수신되었다는 것을 알림 -> 출력 버퍼의 이벤트 -> 출력 버퍼가 비었으니 데이터 전송이 가능한 상황 알림
```

- ex) 카카오톡이 `Non-Blocking` 방식이면 계속 '보낸 메시지가 있는가`를 물어봐야 한다.
  - 이벤트 통지 방식 사용 시 먼저 `입력 버퍼`에서 '사용자가 보낸 메시지 존재'라고 **알림(이벤트 통지 모델)**을 주면 계속 물어보지 않고 다른 작업 가능 (의존성 제거)

<br>

### 이벤트 통지 방식의 2가지 방식

# 동기와 비동기
- **프로세스의 수행 순서 보장에 대한 매커니즘**
- 주로 어플리케이션에서 자주 다뤄지는 개념이며, 다음 작업이 요청되는 시간과 관련

## 1. 동기 모델
<img src="https://github.com/in3166/TIL/blob/main/etc/img/block3.png" width="60%" />

- I/O 작업이 진행디는 동안 유저 프로세스는 결과를 기다렸다 이벤트(결과)를 직접 처리하는 방식
- 이때, 유저는 `Blocking` 방식처럼 다 될 때까지 기다릴 수 있고, `Non-Blocking` 방식처럼 커널에 계속 요청하는 방식으로 기다릴 수 있다. (블로킹처럼 대기 큐에 필수로 머무는 것 x)
- 결국, (시스템콜을 기다린다.)Notify를 유저 프로세스가 담당하여 주체적으로 진행하며 커널은 유저 프로세스의 요청에 수동적으로 응답한다.
<br>

- 현재 작업의 응답이 끝남과 동시에 다음 작업이 요청
- 함수를 호출하는 곳에서 호출되는 함수가 결과를 반환할 때까지 기다린다.
- 작업 완료 여부를 계속해서 확인

<br>

## 2. 비동기 모델
<img src="https://github.com/in3166/TIL/blob/main/etc/img/block4.png" width="60%" />

- I/O 작업 진행 중 유저 프로세스는 자신의 작업을 처리하다가 이벤트 핸들러에 의해 알림이 오면 처리하는 방식
- (시스템콜을 기다리지 않는다.)Notify를 커널이 담당하여 주체적으로 진행
- 유저 프로세스는 수동적인 입장에서 통지가 오면 그때 I/O 처리 (이벤트 핸들러, callback에 의해 운영체제가 결과 통지 받음)
<br>

- 현재 작업의 응답이 끝나지 않은 상태에서 다음 작업이 요청된다.
- 함수를 호출하는 곳에서 결과를 기다리지 않고, 다른 함수(callback)에서 결과를 처리한다.
- 작업 완료 여부를 확인하지 않는다.
<br>

- 상위 프로세스는 작업을 일단 지시했으면 그 다음부터는 작업이 진행 중이든 종료가 되었든 신경쓰지않는다. 
- 동기 방식을 설명했을 때와 마찬가지로 이때 상위 프로세스가 자신의 작업을 할 수 있냐 없냐는 별개의 문제이다.

<br><br>

### 동기 + 블로킹
<img src="https://github.com/in3166/TIL/blob/main/etc/img/block5.png" width="60%" />

- 프로그램이 블로킹을 일으키는 시스템 함수를 호출
- 한 작업당 한 번의 사용자-커널사이의 문맥교환 발생
- 정지된 프로그램은 CPU를 사용하지 않고 커널의 응답을 대기
- 프로그램 관점에서 보면 마치 처리 로직이 오래걸리는 것 같지만, 사실은 커널의 일을 기다리느라 블록되어 있는 것이다.

```JS
function employee () {
  for (let i = 1; i < 101; i++) {
    console.log(`직원: 인형 눈알 붙히기 ${i}번 수행`);
  }
}

function boss () {
  console.log('사장: 출근');
  employee();
  console.log('사장: 퇴근');
}

boss();
// 사장: 출근
// 직원: 인형 눈알 붙히기 1번 수행
///...
// 직원: 인형 눈알 붙히기 100번 수행
// 사장: 퇴근
```
- 작업들이 순서대로 진행
- 상위 프로세스 `boss`는 하위 프로세스 `employee` 함수에게 작업을 요청하고 이 작업이 완료되어야 퇴근할 수 있다.
<br>

### 동기 + 논-블로킹
<img src="https://github.com/in3166/TIL/blob/main/etc/img/block6.png" width="60%" />
- `동기`: 작업이 순차적으로 이루어진다. (`동기` !== `블로킹`)
- 동기블로킹의 개선안이지만 비효율적이다. 왜냐하면 논블로킹방식은 정상데이터가 올 때 까지 계속 시스템콜을 하며 문맥교환을 한다.
- IO 지연(latency) 초래한다

- JavaScript의 제너레이터를 사용하면 작업의 순서를 지키면서 상위 프로세스가 다른 작업 가능하다.
```js
function* employee () {
  for (let i = 1; i < 101; i++) {
    console.log(`직원: 인형 눈알 붙히기 ${i}번 수행`);
    yield;
  }
  return;
}

function boss () {
  console.log('사장: 출근');

  const generator = employee();
  let result = {};

  while (!result.done) {
    result = generator.next();
    console.log(`사장: 유튜브 시청...`);
  }

  console.log('사장: 퇴근');
}

boss();
// 사장: 출근
// 직원: 인형 깔알 붙히기 1번 수행
// 사장: 유튜브 시청...
// 직원: 인형 눈알 붙히기 2번 수행
// 사장: 유튜브 시청...
// ...
// 직원: 인형 눈알 붙히기 100번 수행
// 사장: 유튜브 시청...
// 사장: 퇴근
```
<br>


### 비동기 + 블로킹
<img src="https://github.com/in3166/TIL/blob/main/etc/img/block7.png" width="60%" />
- I/O는 논블로킹이고 알림(notify)가 블로킹인 방식이다.
- select() 시스템함수 호출이 사용자프로세스를 블로킹한다.
- 비효율적이다.
<br>

- Linux와 Unix 운영체제의 I/O 다중화 모델 정도의 저레벨에서 사용
- 보기에 비효율적일 수 있다.
  - 비동기 방식의 장점: 하위 프로세스의 작업 완료를 기다리지 않고 여러 개의 작업을 처리하는 것
  - 하지만, 블로킹되어 유휴 상태에 빠지면 아무 것도 처리할 수 없다.

- 왜 쓰는가?
  - 동기 + 블로킹 I/O의 겨우 직관적이나, 여러 개의 I/O를 동시에 처리할 수 없다.
  - 논블로킹 I/O는 프로세스들의 작업을 컨트롤하기 어렵다.
  - 동기+블로킹I/O와 멍티 프로세싱이나 쓰레딩을 결합해 쓰면 자원 문제와 프로세스/스레드 간 통신, 동기화가 어렵다.
  - 그래서, 프로세스를 블로킹해놓고 비동기로 여러 개의 I/O를 다중화해서 받아버린다.
  - 즉, 직관적인 코드의 흐름을 유지하면서도 작업을 동시에 처리

- 위 그림의 `select()`가 프로세스를 블록킹함과 동시에 여러 개의 I/O를 받아 처리하는 역할
  - 일정 시간동안 프로세스를 멈춰놓고 자신이 감시하고 있는 파일들에서 I/O가 발생하는지를 감시하는 것
  - 일정 시간이 지나면 함수가 종료되며 그동안 감시했던 파일들의 I/O 결과를 반환하고 프로세스의 블록킹이 풀린다.
<br>

### 비동기 + 논-블로킹
<img src="https://github.com/in3166/TIL/blob/main/etc/img/block8.png" width="60%" />

- 시스템콜이 즉시 IO 개시 여부를 반환한다. 사용자프로세스는 다른일을 할 수 있고(CPU는 다른 업무를 볼 수 있다), I/O는 백그라운드에서 처리된다.
- I/O 응답이 도착하면 신호나 콜백으로 I/O전달을 완료한다.

```js
function employee (maxDollCount = 1, callback) {
  let dollCount = 0;
  const interval = setInterval(() => {
    if (dollCount > maxDollCount) {
      callback();
      clearInterval(interval);
    }
    dollCount++;
    console.log(`직원: 인형 눈알 붙히기 ${dollCount}번 수행`);
  }, 10);
}

function boss () {
  console.log('사장: 출근');
  employee(100, () => console.log('직원: 눈알 결산 보고'));
  console.log('사장: 퇴근');
}

boss();
// 사장: 출근
// 사장: 퇴근
// 직원: 인형 눈알 붙히기 1번 수행
// 직원: 인형 눈알 붙히기 2번 수행
// ...
// 직원: 인형 눈알 붙히기 100번 수행
// 직원: 눈알 결산 보고
```
- 비동기: 상위 프로세스는 하위 프로세스의 작업 완료 여부를 신경쓰지 않는다.
  - 이후 하위 프로세스의 작업이 종료되면 상위 프로세스에 보고를 하든 다른 프로세스에 일을 맡기든 한다.

- 논블로킹: 상위 프로세스는 하위 프로세스에게 일을 맡기고 자신의 작업을 계속 수행 가능


<br><br>

### Non-Blocking VS 비동기
- `비동기 모델`은 프로세스가 블록 상태가 되지 않는 점에서 `Non-Blocking I/O`와 같지만 
- `비동기 I/O`는 I/O처리를 완료했을 때 통지를 하는 반면 `Non-Blocking I/O`는 I/O가 처리 가능한 상태를 오류로 판단하는 차이

- `Non-Blocking I/O`는 처리가 완료되지 않으면 에러를 회신하고, 블록 상태로 만들지 않는다.
- 반면 `비동기 I/O`는 처리를 바로할 수 없을 때, 처리가 완료 되는 시점까지 백그라운드에서 대기하고, 종료한 타이밍을 회신하는 차이가 있다.

### 요약
- 블로킹(Blocking): I/O 작업 기다림 O / 대기 큐 stay O
- 논블로킹(Non-Blocking): I/O 작업 기다림 O / 대기 큐 stay X
- 동기(Synchronous): I/O 작업 기다림 O / 대기 큐 stay X
- 비동기(Asynchronous) : I/O 작업 기다림 X / 대기 큐 stay X




<br><br><br>
<출처>
- https://junshock5.tistory.com/148
- https://grip.news/archives/1304
- https://sjh836.tistory.com/109 
- https://evan-moon.github.io/2019/09/19/sync-async-blocking-non-blocking/#%EB%8F%99%EA%B8%B0-%EB%B0%A9%EC%8B%9D--%EB%85%BC%EB%B8%94%EB%A1%9D%ED%82%B9-%EB%B0%A9%EC%8B%9D
