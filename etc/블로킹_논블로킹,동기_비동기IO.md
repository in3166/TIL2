# Blocking I/O
- CPU의 기본적인 I/O 모델
- 리눅스에서 모든 소켓 통신의 기본 동작 방식
- I/O 작업이 진행되는 동안 유저 프로세스는 자신의 작업을 중단한 채 대기하는 방식
- 애플리케이션 실행 시 운영체제 대기 큐에 들어가면서 요청에 대한 system call이 완료된 후에 응답을 보낸다.


<img src="https://github.com/in3166/TIL/blob/main/etc/img/block1.png" width="60%" />

```
1. User가 커널에 Read 작업 요청
2. 데이터 입력까지 대기
3. 데이터가 입력되면 User에게 커널이 결과 전달
```
<br>

# Non-Blocking I/O
- I/O 작업이 진행되는 동안 유저 프로세스는 자신의 작업을 중단시키지 않는 방식
  - 애플리케이션 실행 시 운영체제 대기 큐에 들어가지 않고, 실행 여부와 관계없이 바로 응답을 보낸다. 
  - 바로 응답하기 힘든 경우, 에러를 반환하는데 정상데이터를 받을 때까지 계속해서 요청을 다시 보낸다.
  
- 호출 직후 프로그램으로부터 제어가 돌아옴으로서 시스템 호출 종료를 기다리지 않고 다음 처리로 넘어간다.

<img src="https://github.com/in3166/TIL/blob/main/etc/img/nonblock1.png" width="60%" />

```
1. User가 커널에 Read 작업 요청
2. 데이터 입력 유무에 상관없이 바로 결과 반환 (데이터 없으면 없다는 결과 메시지 EWOULDBLOCK)
3. 데이터가 입력되면 1-2 반복 (2번에서 결과 메시지를 받은 유저는 다른 작업 진행)
4. 입력 데이터가 있다면 커널이 유저에게 결과 전달
```

<br><br>

# I/O 이벤트 통지 모델
- `Non-Blocking I/O`는 반복적으로 시스템 호출이 발생해 자원 낭비 발생
- 이벤트: `수신 버퍼`나 `출력 버퍼`에서 데이터를 처리하는 동작

```
수신 버퍼의 이벤트 -> 입력 버퍼에 데이터가 수신되었다는 것을 알림 -> 출력 버퍼의 이벤트 -> 출력 버퍼가 비었으니 데이터 전송이 가능한 상황 알림
```

- ex) 카카오톡이 `Non-Blocking` 방식이면 계속 '보낸 메시지가 있는가`를 물어봐야 한다.
  - 이벤트 통지 방식 사용 시 먼저 `입력 버퍼`에서 '사용자가 보낸 메시지 존재'라고 **알림(이벤트 통지 모델)**을 주면 계속 물어보지 않고 다른 작업 가능 (의존성 제거)

<br>

# 이벤트 통지 방식의 2가지 방식
## 1. 동기 모델
<img src="https://github.com/in3166/TIL/blob/main/etc/img/block3.png" width="60%" />

- I/O 작업이 진행디는 동안 유저 프로세스는 결과를 기다렸다 이벤트(결과)를 직접 처리하는 방식
- 이때, 유저는 `Blocking` 방식처럼 다 될 때까지 기다릴 수 있고, `Non-Blocking` 방식처럼 커널에 계속 요청하는 방식으로 기다릴 수 있다. (블로킹처럼 대기 큐에 필수로 머무는 것 x)
- 결국, (시스템콜을 기다린다.)Notify를 유저 프로세스가 담당하여 주체적으로 진행하며 커널은 유저 프로세스의 요청에 수동적으로 응답한다.

<br>

## 2. 비동기 모델
<img src="https://github.com/in3166/TIL/blob/main/etc/img/block4.png" width="60%" />

- I/O 작업 진행 중 유저 프로세스는 자신의 작업을 처리하다가 이벤트 핸들러에 의해 알림이 오면 처리하는 방식
- (시스템콜을 기다리지 않는다.)Notify를 커널이 담당하여 주체적으로 진행
- 유저 프로세스는 수동적인 입장에서 통지가 오면 그때 I/O 처리 (이벤트 핸들러, callback에 의해 운영체제가 결과 통지 받음)

<br>

### 동기 블로킹
<img src="https://github.com/in3166/TIL/blob/main/etc/img/block5.png" width="60%" />

- 프로그램이 블로킹을 일으키는 시스템 함수를 호출
- 한 작업당 한 번의 사용자-커널사이의 문맥교환 발생
- 정지된 프로그램은 CPU를 사용하지 않고 커널의 응답을 대기
- 프로그램 관점에서 보면 마치 처리 로직이 오래걸리는 것 같지만, 사실은 커널의 일을 기다리느라 블록되어 있는 것이다.

### 동기 논-블로킹
<img src="https://github.com/in3166/TIL/blob/main/etc/img/block6.png" width="60%" />

- 동기블로킹의 개선안이지만 비효율적이다. 왜냐하면 논블로킹방식은 정상데이터가 올 때 까지 계속 시스템콜을 하며 문맥교환을 한다.
- IO 지연(latency) 초래한다

### 비동기 블로킹
<img src="https://github.com/in3166/TIL/blob/main/etc/img/block7.png" width="60%" />

- IO는 논블로킹이고 알림(notify)가 블로킹인 방식이다.
- select() 시스템함수 호출이 사용자프로세스를 블로킹한다.
- 비효율적이다.

### 비동기 논-블로킹
<img src="https://github.com/in3166/TIL/blob/main/etc/img/block8.png" width="60%" />

- 시스템콜이 즉시 IO 개시 여부를 반환한다. 사용자프로세스는 다른일을 할 수 있고(CPU는 다른 업무를 볼 수 있다), IO는 백그라운드에서 처리된다.
- IO 응답이 도착하면 신호나 콜백으로 IO전달을 완료한다.

<br><br>

### Non-Blockin VS 비동기
- `비동기 모델`은 프로세스가 블록 상태가 되지 않는 점에서 `Non-Blocking I/O`와 같지만 
- `비동기 I/O`는 I/O처리를 완료했을 때 통지를 하는 반면 `Non-Blocking I/O`는 I/O가 처리 가능한 상태를 오류로 판단하는 차이

- `Non-Blocking I/O`는 처리가 완료되지 않으면 에러를 회신하고, 블록 상태로 만들지 않는다.
- 반면 `비동기 I/O`는 처리를 바로할 수 없을 때, 처리가 완료 되는 시점까지 백그라운드에서 대기하고, 종료한 타이밍을 회신하는 차이가 있다.

### 요약
- 블로킹(Blocking): I/O 작업 기다림 O / 대기 큐 stay O
- 논블로킹(Non-Blocking): I/O 작업 기다림 O / 대기 큐 stay X
- 동기(Synchronous): I/O 작업 기다림 O / 대기 큐 stay X
- 비동기(Asynchronous) : I/O 작업 기다림 X / 대기 큐 stay X




<br><br><br>
<출처>
- https://junshock5.tistory.com/148
- https://grip.news/archives/1304
- https://sjh836.tistory.com/109 
