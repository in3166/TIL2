# Testing

- Manual Testing
  - 코드를 작성하고 브라우저에 시험적으로 직접 테스트
  - 오류 발생이 쉽다. (모든 시나리오를 테스트하기 어렵다.)

## Automated Testing

- 자동화 테스트는 코드가 작성되어 실행되면 테스트를 자동으로 진행
- 전체 애플리케이션을 자동으로 테스트하는 코드를 작성하므로 항상 모든 것을 테스트할 수 있다.
- 앱의 각각의 구성 요소들을 코드가 변경될 때마다 모두 테스트한다.
- 오류를 쉽게 잡을 수 있게 된다.

### 단위 테스트 Unit Test

- 가장 작은 단위(functions, components)에 대한 테스트를 작성
(Test the individual building blocks in isolation)
- 프로젝트에는 수 십, 수 백개의 단위 테스트를 가지고 있다.
- 그러므로, 가장 일반적이고 중요한 테스트이다.
- 모든 개별 단위를 테스트하면 전체 애플리케이션도 잘 작동한다는 아이디어

### 통합 테스트 Integration Test

- 모든 단위들을 모아두면 정말로 잘 작동하는지 테스트
- 여러 개의 구성 요소들의 조합을 테스트
(Test the combination of multiple building blocks)
- 프로젝트는 일반적으로 몇몇의 통합 테스트를 포함한다.
  - 단위 테스트와 구별하기 어려울 수 있다. (컴포넌트 테스트 시 다른 컴포넌트를 사용하기도 하므로)

### 전 구간 테스트 End-to-End (e2e) Test

- 애플리케이션의 전체 시나리오(워크플로우)를 테스트
  - '로그인 -> 특정 페이지 이동' 같이 실제로 웹사이트를 사용하는 것처럼
- 단위, 통합 테스트보다는 덜 중요하다.
  - 단위, 통합테스트가 잘 작동하면 전체 앱도 잘 작동한다고 생각할 수 있기 때문

<br>

## 필요한 Tools & Setup

- 테스트를 실행하고 결과를 평가하는 도구 (`jest`)
- 리액트 앱/컴포넌트를 렌더링(simulating)하는 도구 (`React Testing Library`)

## 테스트 작성의 3 가지 과정

- `Arrange (준비)`
  - 테스트 data, conditions, 환경을 설정
  - 컴포넌트 렌더링 `render`

- `Act (실행)`
  - 실제로 테스트하고자 하는 걸 실행
  - 버튼을 클릭해 시뮬레이션 하기 등

- `Assert (단언)`
  - 실제 실행 결과와 예상되는 결과를 비교한다.

```js
import { render, screen } from 'test-util'
import SummaryPage from '../index'

test('checkbox and button', () => {
  // Arrange
  render(<SummaryPage />)
 
  // Assert
  const checkbox = screen.getByRole('checkbox', {
    name: '주문하려는 것을 확인하셨나요?',
  })
  expect(checkbox.checked).toEqual(false)
})
```

- `screen`
  - 가상 DOM, 가상 화면에 액세스하게 해준다.
  - 화면에서 엘리먼트를 찾을 수 있다. (get, find, query 함수 사용)
  - 존재하지 않는 엘리먼트를 찾을 떈 `query`를 사용하면 `null`을 반환, 그 후 `toBeNull()`로 테스트

- `userEvent`
  - 실제 화면에서 사용자 이벤트를 작동시키도록 돕는 객체
  - 클릭, 더블 클릭, 호버링, 타이핑 등

<br>

## 연결되어 상호작용하는 컴포넌트 테스트

```js
// Output.js
const Output = props = {
  return <p>{props.children}</p>
};

// Greeting.js
// ...
return (
  <Output>It</Output>
)

// Greeting.test.js
// ...
```

- 기술적으로 하나 이상의 유닛, 컴포넌트가 관여 됐으므로 통합테스트라 할 수 있다.
- 하지만, 특별히 로직이 없는 wrapper component이므로 정확한 표현은 아니다.
- 이렇게 결합되어 있는 경우 테스트를 분리할 필요는 없다.
- 만약, Output 컴포넌트카 좀 더 복잡하고 `state`를 관리한다면 분리하는게 좋다.

<br>

## 비동기 코드 테스트

```js
// Async.js
const Async = () => {
  const [posts, setPosts] = useState([]);;
  
  useEffect(() => {
    fetch('http://somwhere/posts')
      .then((response) => response.json())
      .then((data) => {
        setPosts(data);
      })
  }, [])

  return (
    <div>
      <ul>
        {post.map((post) => (
          <li key={post.key}>{post.title}</li>
        ))}
      </ul>
    </div>
  )
}

// Async.test.js
describe('Async Component', () => {
  test('renders posts if request succeeds', async () => {
    render(<Async />)

    // const listItemElements = screen getAllByRole('listitem');

    // find를 사용 => Promise를 반환한다. HTTP 요청이 성공할 때까지 기다림
    // 세번째 인자는 Timeout
    const listItemElements = await screen findAllByRole('listitem', {}, {});
    // 처음에는 빈 배열로 랜더링 된다.
    expect(listItemElements).not.toHaveLength(0); // error
  })
})
```

- 일반적으로 테스트 실행 시 서버에 HTTP 요청을 보내지 않는다.
  - 많은 네트워크 트래픽을 일으켜 서버 과부화 가능
  - 서버에 POST를 요청한다면 서버의 내용이 변경될 수 있다.

- 대안
  - 1. 실제로 요청을 전송하지 않는다.
  - 2. 테스팅 서버로 요청한다.

### Mock 을 사용하기 (1)

- 테스트를 할 때 내가 작성하지 않은 코드를 테스트하면 안된다.
- 예를 들어 위의 `fetch` 함수가 잘 작동한다고 믿고 테스트한다. (요청 전송 성공 여부 테스트 x)
- 대신 요청의 서로 다른 결과에 따라 컴포넌트가 올바로 작동하는지 테스트한다.
<br>

- 내장 함수(fetch) 대신 원하는 바대로 수행하면서 실제론 요청을 보내지 않는 더미 함수를 사용

```js
describe('Async Component', () => {
  test('renders posts if request succeeds', async () => {
    window.fetch = jest.fn();
    // fetch 함수가 호출될 때 결정되어야 하는 값을 설정
    window.fetch.mockResolvedValueOnce({
      // json() 도 마찬가지로 프로미스 반환
      json: async () => [{id: 'p1', title: 't1'}]
    });

    render(<Async />)

  })
})
```

- `react-hooks-testing-library`
  - 커스텀 훅 테스트를 간편하게 해주는 라이브러리