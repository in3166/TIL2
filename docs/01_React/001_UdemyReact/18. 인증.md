# 인증이 필요한 이유 (Authentication)

- 일부 콘텐츠는 보호가 필요하며 모든 사용자(방문자)가 모든 콘텐츠에 접근할 수 있으면 안된다.
- `어떤 페이지`들은 인증되지 않으면 잠궈야 하는 경우 존재
  - 비밀번호 변경 페이지: 로그인한 유저만 자신의 비밀번호를 변경할 수 있게 해야한다.

- `보호되어야 하는 데이터`들 또한 인증이 필요하다.
  - 일부 API의 엔드포인트의 경우 인증되지 않은 사용자의 요청은 잠궈야하는 경우 존재
  - 로그인하지 않은 유저가 비밀번호 변경 API 요청을 보내면 해당 요청을 Lock
<br>

# 인증은 어떻게 작동하는가

- 일반적으로 2가지 단계

- 1) 로그인하여 자격 증명을 제공함으로써 이 사용자에 대한 위한 액세스 권한을 얻는다.

  - 회원 가입 -> 로그인 -> 사용자 정보가 서버로 전송 -> 데이터베이스의 정보와 대조 확인 (본인 증명)
  
<br/>

- 2) 대조한 내용이 유효하면 요청이 전송된 백엔드에서 권한을 승인(전송)한다.
  - 이 권한을 얻으면 특정 페이지 잠금을 해제할 수 있고 필요한 작업에 따라 해당 권한을 사용
  - ex. 해당 권한으로 다른 API 엔드포인트의 보호된 리소스에 후속 요청을 보낼 수 있다.
  
<br/>

- 위 권한으로 후속 요청을 사용하는 것은 충분하지 않다.
  - `A 'yes' alone is not enough to then access protected resources (API endpoints)`
  - 조작하기 쉬워진다. (yes or no)
  - => 서버가 클라이언트에 다시 보낸 응답은 더 정교한 `인증`이 필요!
<br><br>

# 정교한 인증을 위한 2가지 방법

## Server-side Sessions

- 서버가 액세스 권한을 승인하면 해당 사용자에 대한 `고유 식별자`를 서버에서 생성하고 저장한다.
- 웹 사이트의 모든 인증된 방문자는 서버에 자신의 식별자를 저장하고 있고 클라이언트는 다시 전송 받는다.
- 사용자는 권한이 필요한 요청을 보낼 때 전송받은 식별자를 함께 보내 인증을 확인한다.

- 단점
  - 프론트앤드 서버와 백앤드 서버가 긴밀히 연결되어 있어야 효과적이다.
  - 만약 SPA가 서버A에서 제공되고 백앤드 서버(REST API)가 서버B에서 제공된다면 각 서버는 독립적으로 작동해야한다.
  - ex) 구글 지도 API는 특정 하나의 프론트앤드에 집중하여 coupling 되지 않는다.
    - 해당 서버는 식별자(클라이언트에서 온 정보들 또한)를 저장하지 않고 유연성을 유지해야 한다.
    - 즉, 서버는 무상태여야 한다. (stateless)
    - => so, 인증 토큰 사용

<br><br>

## Authentication Tokens

- Server-side Session과 거의 동일한 아이디어이지만 중요한 차이점 존재

### 작동 방식

- 이메일 및 비밀번호 등의 정보를 서버에 전송
- 서버는 데이터베이스에 저장된 정보와 비교하여 자격증명 검증

- 검증되면 서버는 권한 토큰을 생성
  - 토큰: 어떤 데이터나 코드가 인코딩된 매우 긴 문자열 (이메일 주소 등의 정보를 하나의 문자열로 알고리즘과 키를 가지고 인코딩)

- 생성된 토큰을 서버에 저장하지 않고 클라이언트에 전송

<br><br><br>
<출처>

- Udemy: React 완벽 가이드
