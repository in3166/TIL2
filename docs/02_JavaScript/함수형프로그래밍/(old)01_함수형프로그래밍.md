### 성공적인 프로그래밍
- 좋은 프로그램: 사용성, 성능, 확장성, 기획 변경에 대한 대응력 등
- 좋은 프로그램을 효율적이고 생산적으로 이루는 일

# 함수형 프로그래밍
- 성공적인 프로그래밍을 위해 부수 효과를 지양하고 조합성을 강조하는 프로그래밍 패러다임
- 부수효과를 미워한다. => `순수 함수`를 만든다.
- `조합성`을 강조한다. => 모듈화 수준을 높인다.
<br>

- 순수 함수들을 이용해 조합하여 `모듈화 수준`을 높힌다.
  - 오류는 적고, 안전성은 높힐 수 있다.
  - 재사용성
<br>

- 순수 함수와 일급 함수를 이용하여 조합성을 높혀나가는 프로그래밍
  - 언제 평가해도 상관없는 순수 함수들을 만들고
  - 그 순수 함수들을 들고 다니며 필요할 때 평가하면 다양한 로직 생성
<br>

# 순수 함수
- 부수 효과가 없는 함수
  - 동일한 입력이 들어오면 동일한 결과값을 리턴
  - 받은 인자 외에 외부에 다른 영향을 끼치지 않음 
  - 리턴 값 외에는 외부와 소통하지 않음

```js
function add(a, b) {
  return a + b;
}
console.log( add(10, 8) ); // 동일한 인자 동일한 리턴, 부수효과 없음
```

<br>

## 순수 함수가 아닌 함수들
- 문제가 아닌 순수 합수가 아닌 함수일 뿐

### 동일한 인자, 다른 결과를 리턴하는 함수

  ```js
  var c = 10; // 프로그래밍 과정에서 변화될 가능성이 있다. (만약 상수로 존재한다면 순수 함수)
  function add2(a, b) {
    return a + b +c;
  }
  console.log( add2(10, 8) );
  c = 1;
  console.log( add2(10, 8) ); // 결과 바뀜
  ```

### 부수 효과를 일이키는 함수
- 외부의 상태를 변경

  ```js
  function add3(a, b){
    c = b;
    return a + b;
  }
  ```

  - return 값으로 외부와 소통하는 것 이외에 외부의 상태에 영향을 미치는 출력이 존재
  - 결과 자체는 동일한 결과, 하지만 외부의 c의 값이 바뀜

  <br>
  
- 들어온 인자의 상태를 직접 변경

  ```js
  var obj = { val : 10};

  function add4(obj, b){
    obj.val += b;
  }
  ```

  - return 값 없음
  - 직접 인자로 들어온 상태를 변경 (obj.val 변경)

`객체를 주로 다뤄서 프로그래밍을 하는데 그럼, 객체를 수정할 수 없는가?`
  - 함수형 프로그래밍은 객체의 값들을 바꿔가지만 방식을 좀 달리한다.
  - 원래 있던 값을 유지하며 값을 복사하여 원하는 변경된 새로운 값을 리턴
  - 순수 함수

  ```js
  var obj1 = { val: 10 };
  function add5(obj, b){
    return { val: obj.val + b } // obj를 참조할 뿐, 직접 값을 변경하지 않고 obj와 동일하게 생긴 새로운 객체 리턴
  }
  console.log(obj1);
  var obj2 = add5(obj1, 20);
  console.log(obj1);
  console.log(obj2);
  ```

<br>
 
## 순수 함수의 특징
- 평가 시점이 중요하지 않다. (코드가 계산된 시점)
  - `add2`는 시점에 따라 리턴값이 바뀌는 함수 (평가 시점이 중요)
  - 언제 실행해도 동일한 리턴 -> 조합성 강조 가능
  - 언제 평가되도 상관없기 때문에 평가 시점을 개발자가 다룰 수 있다.
    - 다른 함수의 인자, 서로 다른 스레드나 공간에서 평가시켜도 동일한 리턴 -> 다루기 쉬워진다.
<br>

# 일급 함수
- 함수를 값으로 다룰 수 있다.
- 변수에 할당, 변수에 담은 함수를 인자로 넘기거나 그 인자로 다른 함수가 실행 가능
- 런타임에서 언제나 정의 가능, 저장 가능, 인자로 전달 가능, 원하는 시점에 평가 가능한 함수

```js
// 변수에 함수 담기
var f1 = function(a) { return a * a; };
console.log(f1); // 함수 내용 출력

// 함수를 인자로 담기
function f3( f ){
  return f();
}
f3(function() { return 10; });
```

- 함수를 리턴하는 함수

```js
// add_maker: 일급 함수와 클로저 사용
function add_maker(a){
   return function(b){
     return a + b;
   }
}

var add10 = add_maker(10);
console.log( add10(20) ); //30
```

- 리턴되는 함수는 **클로저**이다.
  - `add_maker`는 'a'라는 값을 받아서 그 'a'라는 값을 알고 있는 context에서 아래 함수를 정의하며 리턴
  - 리턴되는 함수는 스코프 안에서 알고 있는 'a'라는 값을 참조하고 있다. -> 'a'라는 값을 기억하는 클로저이다.

- 리턴되는 함수는 또한 `순수 함수`이다.
  - 'a'는 변수이지만 리턴 함수에서 참조하고 있을 뿐 변경하지 않는다.
  - 'a'라는 변수를 리턴 함수 내부에서만 사용되고 있어 바뀔일도 없다. (즉, 'a'는 항상 동일한 값을 가리킴)
<br>

- 인자로 함수 3개를 받는 함수

  ```js
  function f4( f1, f2, f3 ){
    return f3( f1() + f2() );
  }

  f4(
    function(){ reutrn 1 },
    function(){ return 2 },
    function(a){ return a * a; }
  ) // 9 
  ```

  - 각각의 순수 함수들의 조합 (함수형 프로그래밍)
    - 평가 시점 자유로움(일정하게) -> 비동기, 동시성 실행 시점에서 이 함수가 필요할 때 실행가능
    - 반복문에서 필요한 부분에서 여러 번 사용 등
<br>

### 마이클 포커스 [클로저 프로그래밍의 즐거움]
```
- 함수형 프로그래밍은 애플리케이션, 함수의 구성요소, 언어 자체를 함수처럼 여기도록 만들고, 이러한 함수 개념을 가장 운선수위에 놓는다.
- 함수형 사고방식은 문제의 해결 방법을 동사(함수)들로 구성(조합)하는 것
```

- 함수를 우선순위로 두는 프로그래밍

  ```js
  // 데이터(객체) 기준
  duck.moveLeft();
  duck.moveRight();
  dog.moveRight();

  // 함수 기준
  moveLeft(dog);
  moveRight(duck);
  moveLeft({ x: 5, y: 2});
  ```
  
  - 함수와 객체 중 무엇이 먼저 나오느냐
    - 객체 지향: 데이터를 먼저 디자인하고 그에 맞는 메서드를 개발
  - 함수형 프로그래밍
    - 함수를 먼저 만들고 그에 맞는 데이터를 만든다.



<br><br><br>
<출처>
- https://www.inflearn.com/course/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/lecture/6774?tab=curriculum&speed=1.75
