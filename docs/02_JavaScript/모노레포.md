# 모노레포 (monorepo)

- 버전 관리 시스템에서 두 개 이상의 프로젝트 코드가 동일한 저장소에 저장되는 소프트웨어 전략
<br>

## 모놀리식 애플리케이션 (Monolith Application)

- 모듈화 없이 설계된 소프트웨어 애플리케이션
- 모듈화 없이 하나의 프로젝트로 구성되면 코드가 서로 직접적으로 의존하며 단 하나의 버전으로 관리되면 관심 분리(SoC, 구별된 부분으로 분리, 모듈식)가 어려워진다.
- 또한 설계, 리팩터링, 배포 등의 작업이 거대한 단위로 처리되야 한다.

## 모듈화와 재사용성

- 모듈화를 통해 모놀리식 한계를 해결
- 로직의 일부를 재사용할 수 있도록 지원하고 전체 교체 없이 애플리케이션 일부를 수정할 수 있다.
<br>

## 멀티레포 (multirepo)

- 폴리레포(polyrepo)라고도 한다.
- 모듈을 독자적인 저장소에서 관리한다.
  - 즉, 각 모듈의 멀티레포 구조에서 고유한 저장소가 있는 **독자적인 프로젝트**가 된다.
  - 각 프로젝트는 자율성이 높고 독립적이 개발, 린트, 테스트, 빌드, 배포 파이프라인이 존재

### 멀티레포 문제점

- 자율성이 고립에 의해 제공되고 고립은 협업을 방해한다.
- `번거로운 프로젝트 생성`
  - 새로운 공유 패키지 생성마다 다음 과정을 거쳐야한다.
  - 저장소 생성 > 커미터 추가 > 개발 환경 구축 > CI/CD 구축 > 빌드 > 패키지 저장소에 publish

- `패키지의 중복 코드 가능성`
  - 각 프로젝트에서 공통 요소를 자체적으로 작성하면 초기 시간을 아끼지만 나중엔 보안 및 품질 관리 부담이 증가한다.

- `관리 포인트 증가`
  - 프로젝트 저장소 수만큼 관리 포인트가 늘어남
  - 린트, 테스트, 개발 모드 실행, 빌드, 게시, 배포 등의 과정을 반복

- `일관성 없는 개발자 경험(DX)`
  - 각 프로젝트는 고유한 명령 집합을 사용하는데 이런 불일치는 각 프로젝트에서 사용할 명령을 기억해야 한다.

- `다른 패키지의 변경 사항 파악`
  - 관련 패키지 변화를 지켜보거나 통지받지 않으면 문제 발생 가능

- `교차 저장소의 리팩터링 비용`
  - 관련 패키지 변화가 있을 때 여러 저장소에 걸쳐 변화를 반영하기 어렵다.

- `코드 컨벤션 통일이 힘듦`
- `사용하는 모듈 및 버전 스택이 달라질 가능성`
<br>

- 모듈을 적절히 분리하여 관심사 분리를 이루고, 동시에 분리된 모듈을 쉽게 참조하고 테스트, 빌드, 배포 과정도 쉽게 한 번에 할수 있는 방법이 필요해졌다.

<br>

## 모노레포의 특징

- 두 개 이상의 프로젝트가 동일한 저장소에 저장되는 소프트웨어 개발 전략
- 분리된 모듈은 여전히 독자적인 프로젝트로 존재하지만 `같은 저장소`을 사용한다.
- 또한, 같은 저장소에 존재하는 여러 프로젝트 사이에는 `의존성`이 존재하거나 같은 `정의된 관계`가 존재한다.

- 모노레포 관리 도구를 통해 이런 관계를 효율적으로 관리해준다.

- 테스트 및 빌드 범위 최소화
  - 소스 변경 시 모든 프로젝트를 다시 빌드하거나 다시 테스트하지 않는다.
  - 변경 사항에 영향을 받은 프로젝트만 다시 테스트하고 빌드한다.

<img src="02_JavaScript/img/image.png" width="80%" />
(https://d2.naver.com/helloworld/0923884)

### 멀티레포 문제 해결

- 더 쉬운 프로젝트 생성
  - 저장소 생성 및 커미터 추가 과정이 필요 없고 개발 환경, CI/CD, 빌드, 게시 등의 과정에 기존 DevOps를 사용한다.

- 더 쉬운 의존성 관리
  - 의존성 패키지가 같은 저장소에 있으므로 버전이 지정된 패키지를 `npm refistry` 같은 것에 publish할 필요가 없다.

- 단일화된 관리 포인트
  - 개발환경 및 DevOps에 대한 업데이트를 한 번에 반영 가능

- 일관된 개발자 경험 제공
  - 애플리케이션을 일관되게 구축하고 테스트 가능
  - 개발자는 다른 팀의 애플리케이션에 자신 있게 기여하고 변경 사항이 안전한지 확인 가능

- 프로젝트들에 걸친 원자적 커밋
  - 커밋마다 모든 것이 함께 작동, 변경 사항의 영향을 받는 조직에서 쉽게 변화 확인 가능

- 서로 의존하는 저장소들의 리팩터리 비용 감소
  - 대규모 변경을 간단하게 만든다.

### 언제 사용할까?

- 유사한 제품의 집합
- 여러 프로젝트의 변화를 한눈에 파악해야 할 때
- 호스트 애플리케이션을 플러그인 등으로 확장할 때
- 공통 기능을 재사용하는 관련된 프로젝트의 집합
- 유사한 DevOps로 구성된 프로젝트의 집합

### 고려 사항

- 관리 측면
  - 코드 공유: 서로 다른 프로젝트 간에 쉽게 소스 코드를 공유

  - 일관성 있는 도구: 서로 다른 프로젝트들(심지어 서로 다른 프레임워크를 사용하더라도)에서 일관된 개발 경험을 제공

  - 스케폴딩: 새로운 프로젝트를 생성할 때 초기 코드를 쉽게 생성

  - 프로젝트 제약 및 가시성(visibility): 저장소 내에서 의존 관계를 제한하는 규칙 정의 지원. 예를 들어, 일부 프로젝트를 팀 전용으로 표시하거나 특정 프레임워크을 사용 중임을 기술.

- 속도 측면
  - 로컬 캐싱: 같은 머신에서 같은 것을 두 번 빌드하거나 테스트하지 않음

  - 분산 캐싱: 다양한 환경에서 캐시 아티팩트를 공유. 즉, 조직 단위로 여러 CI 환경에 걸쳐 같은 것을 두 번 빌드, 테스트하지 않음

  - 로컬 작업 오케스트레이션: 빌드 및 테스트 등의 작업을 순서에 맞게 병렬로 실행

  - 분산 작업 실행: 단일 시스템에서 실행되어 여러 시스템에 명령을 전달

  - 변화에 영향을 받는 프로젝트 감지: 변경의 영향을 받을 수 있는 항목을 결정하여 영향을 받는 프로젝트만 빌드/테스트

- 구조 파악 측면
  - 워크스페이스 분석: 추가 구성 없이 주어진 워크 스페이스의 의존성 관계를 분석

  - 의존성 그래프 시각화: 프로젝트 및 작업 간의 종속 관계를 시각화

<br><br><br>

<출처>

- <https://d2.naver.com/helloworld/0923884>
- <https://blog.mathpresso.com/%ED%8C%80%EC%9B%8C%ED%81%AC-%ED%96%A5%EC%83%81%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%AA%A8%EB%85%B8%EB%A0%88%ED%8F%AC-monorepo-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B5%AC%EC%B6%95-3ae1b0112f1b>
