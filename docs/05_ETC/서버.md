# 서버 (Server)
- 하드웨어: 클라이언트에게 네트워크를 통해 `서비스를 제공`해주는 컴퓨터
- 소프트웨어: 어떤 컴퓨터로 하여금 서버 역할(요청에 대한 응답을 넘겨주는 모든 것들)을 하도록 해주는 소프트웨어 ('서버를 개발한다.' 할 때)
  
## 웹 서버 (Web Server)
- 소프트웨어 개념 (ex: 아파치, NginX)
- 컴퓨터를 웹사이트를 제공하는 서버로 만들어주는 서비스
  - 웹사이트 서비스 시 필요한 것들 (**정적인 컨텐츠**)
    - HTML, CSS, JS, Resource 들을 서버에서 사용자 컴퓨터에 보낼 수 있어야한다.
    - 즉, 웹서버는 서버의 특정 폴더에 있는 파일들을 개방하여 특정 주소로 접근하면 이것들을 받을 수 있도록 해주는 역할을 한다.

- 대표적 웹 서버
  - 아파치
    - Apache, PHP, MySQL 연동 -> 동적 웹사이트 제공: APM
  - NginX
  - IIS: 윈도우용

## WAS (Web Application Server)
- 웹 서버가 클라이언트로부터 요청을 받으면 애플리케이션의 로직을 실행하여 다시 웹 서버로 반환해주는 소프트웨어
- 웹서버와 DMBS 사이의 미들웨어, 컨테이너 기반 동작

- 자바+JSP로 만든 웹이나 API 애플리케이션을 실행할 때 사용
- 동적 사이트를 전문적으로 처리해 준다. (**동적인 컨텐츠**)
- 자바의 경우에 WAS라고 명확히 구분되어 있고 Node.js의 경우 애플리케이션이 WAS 역할까지 하기도 한다.

- 톰캣 (요즘엔 스프링 부트에 내장되어져 있음)
  - 스프링으로 코딩한 웹앱을 'war' 파일로 빌드하면 그 안에 '.class', jsp, css 파일 등이 압축되어 있다.
  - 톰캣의 특정 폴더에 'war' 파일을 넣고 실행하면 스프링 서비스가 톰캣을 사용해 돌릴 수 있다.
  - 반대로 스프링을 톰캣이 들어있는 'jar' 파일로 빌드해 배포하기도 한다.
  - 정적인 컨텐츠도 직접 사용자에게 전달할 수도 있다.

<img src="05_ETC/img/WAS1.JPG" />

### 웹서버와 WAS를 구분하는 이유
- `부하`가 많은 서비스의 경우 빨리 처리할 수 있는 정적인 컨텐츠를 굳이 WAS 처리하여 부하를 줄 필요가 없다.
- WAS는 사용자들에게 공개되지 않는다. (DB 접속정보 등을 가지고 있음) WAS는 내부망에 위치시켜 `보안`을 유지한다. (웹서버는 DMZ 구간에 위치)

<br>

## Forward Proxy
- 사용자가 사이트에 접속할 때 자신의 IP를 숨기기위해 중간에 Proxy를 둬서 사용

## 웹 서버 사용 이유
### Reverse Proxy
- 사용자들에게서 서버의 정보를 감춘다.
- 웹서버인 아파치나, NginX가 기능 제공
  - 정적 리소스의 위치나 사용 포트, 동적 요소를 만들어 내는 부분 등을 감추기 위해 웹 서버를 앞단에 둬서 전달만 해준다.'
  - 한 서버에 여러 서비스를 제공할 경우 웹서버가 어디로 접속했는지 보고 처리

### 로드 밸런싱

<br>
  
# 프론트 서버
- 주소에 대한 요청을 받으면, markup Language (html, css)를 보내줘 사용자에게 GUI 환경 제공
- 웹 서버에 가까움
 
# 백엔드 서버
- 프론트 서버와 통신하여 클라이언트가 프론트서버에 어떤 요청을 할 때, 사용자 정보나 해당 App의 데이터에 접근 가능하게 해주는 서버
- API 서버에 가까움

<br>
  
- 기본 화면만을 받아올 때는 클라이언트(브라우저) <-> 프론트엔드 서버
- SSR을 할 때는 클라이언트(브라우저) <-> 프론트엔드 서버 <-> 백엔드 서버 <-> DB
- API 요청을 할 때는 클라이언트(브라우저) <-> 백엔드 서버 <-> DB

<br>

## 분리 이유
- 데이터가 많아질 때 관리하기 용이
- 속도 향상

<br><br>

# 일반적인 웹 애플리케이션 (full stack)
- Client가 요청을 보내면 서버에 존재하는 웹 애플리케이션이 데이터베이스 서버와 통신하여 필요한 데이터 가져오고
- 이 데이터로 완전학 HTML, CSS, JavaScript 파일을 만들어 클라이언트에 제공

# React 서버
<img src="05_ETC/img/server.png" />

- 프론트 엔드의 분리
  - React 라이브러리로 사용자에게 제공할 JavaScript 파일: ES6 + JSX 문법으로 코딩,
  - Babel 등의 컴파일러가 모든 브라우저에 호환 가능한 문법(ES5) 코드로 변환
  - Webpack 등의 모듈 번들러가 HTML, CSS, JavaScript 파일들을 효율적으로 번들링하여 준비
  - create-react-app으로 생성한 React 프로젝트의 개발 환경에서 "npm start"로 실행되는 개발 서버(webpack-dev-server)가 파일이 수정될 때마다 변환 작업들을 자동으로 수행
  - 실제 배포 시에는 번들링 한 파일들을 프론트 엔드 서버의 document 루트에 미리 준비해두고 웹 서버가 그 파일들을 제공할 수 있도록 설정

- 클라이언트가 요청을 보내면 미리 준비한 파일들을 제공
- 브라우저는 파일을 실행하여 페이지에 렌더링 시작
- 만약, 렌더링 과정에서 DB 데이터가 필요한 경우 백 엔드 서버에게 API 요청을 보내서 필요한 데이터 요청 (백엔드 서버를 API서버라고 부르는 이유)
- 필요한 데이터를 전달해주는 역할만 수행할 뿐, 정적 리소스를 제공해주지 않기 때문

- 페이지를 리로드하지 않고 부분적 리렌더링이 필요하면 사용자의 액션으 감지하여 백 엔드 서버에 API 요청 (해당 부분의 데이터만 요청)
- JavaScript가 응답 데이터로 필요한 부분만 리렌더링

- 이런 맥락에서 React, Vue, Angular 등을 `SPA (Single Page Application)`이라고 부른다.
- 기본적인 HTML, CSS, JavaScript 파일들만 제공받은 다음 렌더링 필요 부분만 직접 백엔드 서버에게 API 요청을 보내 리렌더링하는 방식 (페이지 깜빡임 없이 작동)



## 문제점
- 다른 컴퓨터(서로 다른 도메인을 가진 프론트와 백)가 서로 통신하기 때문에 CORS 문제 발생
- 서버에서 프론트 요청을 허용해주는 작업 필요

- CORS (Cross-Origin Resource Sharing): 추가 HTTP 헤더를 사용하여 브라우저에게 한 출처에서 실행중인 웹 응용 프로그램의 다른 출처의 선택된 자원 접근 권한 알려주는 메커니즘
  - 다른 도메인 자원 접근을 막는다.
  - 서버는 기본적으로 다른 도메인으로부터 온 요청에 대해 쿠키를 설정 및 응답해주지 않는다. (withCredentials 설정 필요)
  

<br><br><br>

<출처>
- https://it-eldorado.tistory.com/85
- https://velog.io/@kimtaeeeny/%EC%9B%B9%EC%97%90%EC%84%9C%EC%9D%98-%ED%94%84%EB%A1%A0%ED%8A%B8-%EC%84%9C%EB%B2%84-%EB%B0%B1%EC%97%94%EB%93%9C-%EC%84%9C%EB%B2%84-%EA%B0%9C%EB%85%90-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-study6
- https://www.youtube.com/watch?v=Zimhvf2B7Es
- https://goldsony.tistory.com/37
  
