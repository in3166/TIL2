# 브라우저 동작 원리
### 1. 주소창에 URL 입력

### 2. 사용자 브라우저의 호스트파일, 브라우저 캐시에 해당 URL 정보가 존재하는지 확인
- 이전에 접속한 적있는 페이지이고 캐싱이 적용되었다면 별도의 DNS 요청없이 URL을 띄운다.
- 호스트 파일(Host file)
  - 호스트 이름에 대응하는 IP 주소가 저장되어 있어 도메인 이름 시스템(DNS)에서 주소 정보를 제공받지 않고도 서버의 위치를 찾게 해주는 파일

### 3. DNS에 실 IP 주소를 요청하고, 리소스를 받을 준비를 한다.
- 호소트의 도메인 이름을 실제 IP 주소로 변환하기 위해 DNS에 요청한다. 

### 4. HTML, CSS 파싱
- 서버로부터 받아온 파일 중 HTML, CSS를 각각 `DOM Tree`, `Style Tree = CSSOM(Object Model)`로 파싱한다.

### 5. Attachment로 렌더링 트리 생성
- `DOM Tree`, `Style Tree`의 시각 정보를 연결하는 Attachment 작업을 통해 `렌더링 트리` 생성
- `렌더링 트리`는 실제 페이지에서 사용되는 노드만을 포함
- 루트부터 탐사하면서 해당 노드에 일치하는 스타일 연결
<img src="" width="60%" />

### 6. 레이아웃(reflow)으로 실제 위치 계산
- 화면 상 어디에 위치할 지 계산 (페이지 내 실제 위치 계산 작업)
- 루트부터 탐사하면서 노드의 화면 상 실제 위치(px)을 계산
- 만약 CSS에서 상대값(5)으로 주었다면, 레이아수 단계에선 절대값(px)로 반환

### 7. 페인트 메서드 호출
- 페인트 메서드 호출하여 렌더링 트리의 각 노드를 화면에 실제 그릴 수 있는 레이어 생성
- `래스터화`

### 8. 레이어 합성
- 위에서 생성된 개별 레이어들을 합성하여 렌더링하면 이제 사용자에게 보여줄 화면 완성


- 요약
```
- HTML 마크업을 처리하고 DOM 트리 빌드
- CSS 마크업을 처리하고 CSSOM 트리 빌드
- DOM 및 CSSOM을 결합하여 렌더링 트리 형성
- 렌더링 트리에서 레이아웃을 실행하여 각 노드의 기하학적 형태 계산
- 개별 노드를 화면에 페인트
```

- 페이지 로드 완료 후, 사용자 인터렉션 등으로 DOM/CSS 규칙이 수정되어 화면이 다시 렌더링 될 경우 위의 과정을 반복
- 즉, 렌더링 프로세스를 최적화해야 성능 최적화 가능

<br><br>

# 성능 최적화
## 1. 페이지 로드 최적화
### 1.1 블록 차단 리소스 최적화
- HTML 파싱할 때, CSS나 JS를 만나면 HTML 파싱을 중단하고 해당 파일을 파싱하거나 다운로드 후 실행한다.
- 이처럼 HTML 파싱을 차단하는 요소를 `블록 차단 리소스`라고 한다.
<br>

- `블록 차단 리소스`는 렌더링 차단 요소에 속하므로 **올바른 실행 위치에서 코드를 작성**해야 한다.
  - CSS는 `<head>` 태그 안에서 Import
  - JS는 주로 `<body>` 태그 하단에 위치시킨다.
<br>

- **특정 속성**으로 블로킹을 방지할 수 있다.
  - CSS는 `media` 속성으로 어떤 단말기의 유형인지에 따라 해당 CSS를 적용할지 명시하면 불필요한 블로킹 방지 가능
  ```HTML
  <link href="style.css" rel="stylesheet" media="print" or media="width:780px"/>
  ```
  
  - JS는 비동기로 다운로드하도록 명시하면, DOM 트리나 Style 트리를 변경하지 않겠다는 의미이므로 `defer`, `async` 속성을 활용
    - `async`: 스크립트 로드만 병렬적으로 실행하므로 실행 순서를 보장하지 않는다.
    - `defer`: 병렬적으로 파일을 로드하면서 모든 DOM이 로드된 후 스크립트를 실행하므로 실행 순서 보장(파일간 의존성을 지키면서 DOM 요소 접근 가능)
    
  ```html
  <body>
    <div>
    </div>
    <!-- HTML 파싱을 블로킹하지 않고 다운로드 -->
    <script async>
      //...
    </script>  
  </body>
  ```
<br>

- Non-critical CSS 파일의 **로드 방식 변경**하기
  ```HTML
  <head>
   <link crossorigin rel="preload" href="/path/to/style.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
   <noscript><link rel="stylesheet" href="/path/to/style.css"></noscript>
  </head>
  ```
  - `link rel="preload" as="style"`은 `load` 이벤트를 막지 않고 CSS 파일을 요청할 수 있게 해준다.
  - `onload="this.onload=null;this.rel='stylesheet'`은 CSS 파일이 로드 이벤트 이후 파싱되고, `onload` 함수가 제거됨을 보장한다.
  - `noscript` 태그는 JS 사용이 불가능해도 스타일을 로드할 수 있도록 한다.
  - [추후 포스트 PRELOAD, PREFETCH](https://medium.com/@koh.yesl/preload-prefetch-and-priorities-in-chrome-15d77326f646)

- [웹 폰트 최적화](https://web.dev/optimize-webfont-loading/)
<br><br>

### 1.2 리소스 용량 줄이기


<br><br>

### 1.3 리소스 요청 개수 줄이기


<br><br><br>

## 2. 페이지 렌더링 최적화

### 2.1 강제 동기식 레이아웃과 레이아웃 스레싱 피하기

<br><br>

### 2.2 상위 DOM 요소보다 하위 DOM 요소를 사용하기

<br><br>

### 2.3 `display:none;`으로 설정된 속성은 레이아웃이 발생하지 않는 점 활용

<br><br>

### 2.4 `domFragment` 활용하기

<br><br>

### 2.5 시각적인 변화는 `requestAnimtionFrame` API 활용하기

<br><br>

## CSS와 HTML 최적화하는 방법들
### 2.6 CSS에 복잡한 셀렉터 규칙 사용하지 않기

<br><br>

### 2.7 DOM 트리와 Style 트리를 복잡하게 구성하지 않기

<br><br>

### 2.8 애니메이션 요소는 `position` 고정하기

<br><br>

### 2.9 레이아웃보다 리페인트를 발생시키는 속성을 활용하기


<br><br><br>

# 성능 측정 기준
## 1. 브라우저 내부 이벤트 기준

<br><br>

## 2. 사용자 기준 성능 지표

<br><br>

## 3. 사용자 기준 성능 최적화

<br><br><br>
<출처>
- https://coffeeandcakeandnewjeong.tistory.com/34
- https://goddaehee.tistory.com/90 [갓대희의 작은공간]
- https://ui.toast.com/fe-guide/ko_PERFORMANCE
